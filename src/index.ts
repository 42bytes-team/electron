import path from 'path';
import { app, BrowserWindow, ipcMain } from 'electron';
import type { IpcMainInvokeEvent } from 'electron';
import Store from 'electron-store';
import OAuthBuilder from './oauth2';
import type { OauthCredentials } from './oauth2';
import { generateRandomString } from './random';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

if (process.defaultApp) {
    if (process.argv.length >= 2) {
        app.setAsDefaultProtocolClient('wfm-app', process.execPath, [path.resolve(process.argv[1])]);
    }
} else {
    app.setAsDefaultProtocolClient('wfm-app');
}

interface AppConfigs {
    deviceId: string;
    accessToken: string | null;
    refreshToken: string | null;
    expiresAt: number;
}

class Application {
    oauthCredentials: OauthCredentials;
    oauth: OAuthBuilder;
    window?: BrowserWindow;
    store: Store<AppConfigs>;

    constructor() {
        if (!app.requestSingleInstanceLock()) {
            console.debug('app is already running, withdraw');
            app.quit();
        }

        this.store = new Store<AppConfigs>({
            defaults: {
                deviceId: `d-${generateRandomString(16)}`,
                accessToken: null,
                refreshToken: null,
                expiresAt: 0,
            },
        });

        this.oauthCredentials = {
            client_id: '64243a5d316686c642c2a56a',
            device_id: this.store.get('deviceId'),
            redirect_uri: 'wfm-app://oauth2callback',
            scopes: ['orders', 'inventory'],
        };

        this.oauth = new OAuthBuilder(this.oauthCredentials, {
            accessToken: this.store.get('accessToken'),
            refreshToken: this.store.get('refreshToken'),
            expiresAt: this.store.get('expiresAt'),
        });

        this.getDataFromStore = this.getDataFromStore.bind(this);
        this.ready = this.ready.bind(this);
        this.allClosed = this.allClosed.bind(this);
        this.onSecondInstance = this.onSecondInstance.bind(this);
        this.activate = this.activate.bind(this);

        app.on('ready', this.ready);
        app.on('window-all-closed', this.allClosed);
        app.on('second-instance', this.onSecondInstance);
        app.on('activate', this.activate);
    }

    ready() {
        ipcMain.handle('oauth:authorize', () => {
            return this.oauth.authorize();
        });

        ipcMain.handle('oauth:getCurrentUser', () => {
            return this.oauth.getCurrentUser();
        });

        ipcMain.handle('store:get', this.getDataFromStore);
        this.createWindow();
    }

    createWindow() {
        // Create the browser window.
        this.window = new BrowserWindow({
            height: 600,
            width: 800,
            autoHideMenuBar: true,
            webPreferences: {
                preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            },
        });

        // and load the index.html of the app.
        this.window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

        // Open the DevTools.
        this.window.webContents.openDevTools();
        this.window.webContents.openDevTools({ mode: 'detach' });
    }

    // Quit when all windows are closed, except on macOS. There, it's common
    // for applications and their menu bar to stay active until the user quits
    // explicitly with Cmd + Q.
    allClosed() {
        if (process.platform !== 'darwin') {
            app.quit();
        }
    }

    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    activate() {
        if (BrowserWindow.getAllWindows().length === 0) {
            this.createWindow();
        }
    }

    /*
     * This method will be called when second instance of app is launched
     * In our specific case that means that we were redirected from the web browser to our app \
     * And this redirect URL should have code and state attached to it, and we can exchange code to tokens
     */
    async onSecondInstance(event: Electron.Event, commandLine: string[]) {
        // Someone tried to run a second instance, we should focus our window.
        if (this.window) {
            console.debug('app is already running, focus or restore');
            if (this.window.isMinimized()) this.window.restore();
            this.window.focus();
        }

        // the commandLine is array of strings in which last element is deep link url
        const url = commandLine.pop() || '';
        if (url.includes('oauth2callback')) {
            const tokens = await this.oauth.parseAndGetTokens(url);
            if (tokens == null) return;
            this.store.set('accessToken', tokens.accessToken);
            this.store.set('refreshToken', tokens.refreshToken);
            this.store.set('expiresAt', tokens.expiresAt);
            this.window!.webContents.send('event:authorized');
        }
    }

    getDataFromStore(event: IpcMainInvokeEvent, key: string) {
        return this.store.get(key);
    }
}

new Application();
